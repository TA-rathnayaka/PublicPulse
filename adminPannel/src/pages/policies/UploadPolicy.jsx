import React, { useState } from 'react';
import { storage, firestore } from '../../services/firebaseConfig';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { collection, addDoc } from 'firebase/firestore';
import './UploadPolicy.scss';
import { createNotification } from '../../backend/notifications';

const UploadPolicy = () => {
  const [pdfFile, setPdfFile] = useState(null);
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');
  const [category, setCategory] = useState('');
  const [tags, setTags] = useState('');
  const [status, setStatus] = useState('Draft');
  const [createdBy, setCreatedBy] = useState('');
  const [assignedTo, setAssignedTo] = useState('');
  const [createdDate, setCreatedDate] = useState(getCurrentDate());
  const [effectiveDate, setEffectiveDate] = useState('');
  const [expiryDate, setExpiryDate] = useState('');
  const [isActive, setIsActive] = useState(true);
  const [approvedBy, setApprovedBy] = useState('');
  const [approvalDate, setApprovalDate] = useState('');
  const [notes, setNotes] = useState('');
  const [imageUrl, setImageUrl] = useState('');
  const [metadata, setMetadata] = useState('{}');
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingStatus, setProcessingStatus] = useState('');
  const [fileName, setFileName] = useState('');

  // Get current date in YYYY-MM-DD format
  function getCurrentDate() {
    const today = new Date();
    return today.toISOString().split('T')[0];
  }

  // Notify users about new policy
  const notifyUser = async (policyId) => {
    try {
      const notificationId = await createNotification({
        message: "New policy has been published",
        target: "all",  // Target user ID or group
        type: "policy",  // Notification type
        metadata: { policyId: policyId }  // Extra data if needed
      });

      console.log("Notification created with ID:", notificationId);
    } catch (error) {
      console.error("Error notifying user:", error.message);
    }
  };

  // Generate suggestions based on file name
  const generateSuggestionsFromFileName = (name) => {
    setProcessingStatus('Analyzing file name for suggestions...');
    
    // Remove file extension and replace special characters with spaces
    const cleanName = name.replace(/\.[^/.]+$/, "").replace(/[_-]/g, " ");
    
    // Auto-suggest title if empty
    if (!title) {
      // Capitalize first letter of each word
      const formattedTitle = cleanName
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
      
      setTitle(formattedTitle);
    }
    
    // Auto-suggest category if empty
    if (!category) {
      // Common categories to check against file name
      const categoryKeywords = {
        'HR': ['human resources', 'employee', 'staff', 'recruitment', 'personnel', 'hr'],
        'Finance': ['finance', 'financial', 'budget', 'accounting', 'expense'],
        'IT': ['technology', 'software', 'hardware', 'system', 'data', 'security', 'it'],
        'Legal': ['legal', 'compliance', 'regulation', 'law', 'contractual', 'policy'],
        'Operations': ['operation', 'procedure', 'process', 'workflow']
      };
      
      for (const [cat, keywords] of Object.entries(categoryKeywords)) {
        for (const keyword of keywords) {
          if (cleanName.toLowerCase().includes(keyword.toLowerCase())) {
            setCategory(cat);
            break;
          }
        }
      }
    }
    
    // Auto-suggest tags if empty
    if (!tags) {
      const wordSet = new Set();
      cleanName.toLowerCase().split(' ').forEach(word => {
        if (word.length > 3) {
          wordSet.add(word);
        }
      });
      
      // Add common policy-related tags
      if (cleanName.toLowerCase().includes('policy')) {
        wordSet.add('policy');
      }
      
      const suggestedTags = Array.from(wordSet).join(', ');
      setTags(suggestedTags);
    }
    
    // Auto-generate description if empty
    if (!description) {
      setDescription(`This document contains the ${cleanName} information and guidelines. Please review for complete details.`);
    }
    
    // Auto-generate metadata
    const generatedMetadata = {
      fileName: name,
      fileType: name.split('.').pop(),
      uploadDate: new Date().toISOString(),
      autoGenerated: true
    };
    
    setMetadata(JSON.stringify(generatedMetadata, null, 2));
    
    // Auto-generate notes if empty
    if (!notes) {
      setNotes(`Automatically processed on ${new Date().toLocaleString()}\nGenerated from file: ${name}`);
    }
    
    setProcessingStatus('Suggestions generated based on file name');
  };

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setPdfFile(file);
      setFileName(file.name);
      setProcessingStatus('File selected: ' + file.name);
      
      // Start auto-fill process
      setIsProcessing(true);
      generateSuggestionsFromFileName(file.name);
      setTimeout(() => setIsProcessing(false), 800); // Simulate processing
    }
  };

  const handleUpload = async () => {
    if (!pdfFile) return;
    
    try {
      setIsProcessing(true);
      setProcessingStatus('Uploading PDF to storage...');
      
      const storageRef = ref(storage, `policies/${pdfFile.name}`);
      await uploadBytes(storageRef, pdfFile);
      const downloadURL = await getDownloadURL(storageRef);

      setProcessingStatus('Saving policy data to database...');
      
      const policyData = {
        title,
        description,
        category,
        tags: tags.split(',').map(tag => tag.trim()),
        status,
        createdBy,
        assignedTo,
        createdDate,
        effectiveDate,
        expiryDate,
        isActive,
        approvedBy,
        approvalDate,
        pdfUrl: downloadURL,
        imageUrl,
        metadata: JSON.parse(metadata || '{}'),
        notes,
        fileName: pdfFile.name,
        uploadTimestamp: new Date().toISOString()
      };

      const policyRef = await addDoc(collection(firestore, 'policies'), policyData);
      notifyUser(policyRef.id);
      
      setProcessingStatus('Policy uploaded successfully!');
      console.log('Policy added successfully');
      
      // Reset form after successful upload (optional)
      // resetForm();
      
      setTimeout(() => {
        setIsProcessing(false);
        setProcessingStatus('');
      }, 2000);
      
    } catch (error) {
      console.error('Error uploading policy:', error);
      setProcessingStatus(`Error: ${error.message}`);
      setIsProcessing(false);
    }
  };

  const resetForm = () => {
    setPdfFile(null);
    setFileName('');
    setTitle('');
    setDescription('');
    setCategory('');
    setTags('');
    setStatus('Draft');
    setCreatedBy('');
    setAssignedTo('');
    setCreatedDate(getCurrentDate());
    setEffectiveDate('');
    setExpiryDate('');
    setIsActive(true);
    setApprovedBy('');
    setApprovalDate('');
    setNotes('');
    setImageUrl('');
    setMetadata('{}');
    setProcessingStatus('');
  };
  
  const handleIntelligentSuggestions = () => {
    setIsProcessing(true);
    setProcessingStatus('Generating intelligent suggestions...');
    
    // Suggest current user as creator if empty
    if (!createdBy) {
      // This would normally come from user context/auth
      setCreatedBy('Current User');
    }
    
    // Set default expiry date if empty (1 year from effective date)
    if (effectiveDate && !expiryDate) {
      const effectiveAsDate = new Date(effectiveDate);
      effectiveAsDate.setFullYear(effectiveAsDate.getFullYear() + 1);
      setExpiryDate(effectiveAsDate.toISOString().split('T')[0]);
    }
    
    // Suggest status based on other fields
    if (approvedBy && approvalDate) {
      setStatus('Approved');
    } else if (assignedTo) {
      setStatus('In Review');
    }
    
    // Enhance tags with common policy terms if not already present
    if (tags) {
      const currentTags = new Set(tags.split(',').map(tag => tag.trim().toLowerCase()));
      const suggestedTags = ['policy', 'document', 'guideline', 'compliance'];
      
      suggestedTags.forEach(tag => {
        if (!currentTags.has(tag)) {
          currentTags.add(tag);
        }
      });
      
      setTags(Array.from(currentTags).join(', '));
    }
    
    setTimeout(() => {
      setIsProcessing(false);
      setProcessingStatus('Intelligent suggestions applied');
    }, 1000);
  };

  return (
    <div className="upload-policy">
      <h2>Upload New Policy</h2>
      
      {isProcessing && (
        <div className="processing-indicator">
          <p>{processingStatus}</p>
          <div className="progress-bar"></div>
        </div>
      )}
      
      <div className="upload-section">
        <h3>1. Upload PDF Document</h3>
        <input type="file" accept="application/pdf" onChange={handleFileChange} />
        {fileName && <p className="file-name">Selected: {fileName}</p>}
      </div>
      
      <div className="form-section">
        <h3>2. Policy Information</h3>
        <div className="smart-buttons">
          <button type="button" onClick={handleIntelligentSuggestions} className="suggest-button">
            <i className="fas fa-magic"></i> Auto-Fill Suggestions
          </button>
        </div>
        
        <div className="form-grid">
          <div className="form-group">
            <label>Title:</label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Category:</label>
            <select
              value={category}
              onChange={(e) => setCategory(e.target.value)}
            >
              <option value="">Select Category</option>
              <option value="HR">Human Resources</option>
              <option value="Finance">Finance</option>
              <option value="IT">IT & Technology</option>
              <option value="Legal">Legal & Compliance</option>
              <option value="Operations">Operations</option>
              <option value="Other">Other</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>Tags (comma separated):</label>
            <input
              type="text"
              value={tags}
              onChange={(e) => setTags(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Status:</label>
            <select
              value={status}
              onChange={(e) => setStatus(e.target.value)}
            >
              <option value="Draft">Draft</option>
              <option value="In Review">In Review</option>
              <option value="Approved">Approved</option>
              <option value="Published">Published</option>
              <option value="Archived">Archived</option>
            </select>
          </div>
          
          <div className="form-group">
            <label>Created By:</label>
            <input
              type="text"
              value={createdBy}
              onChange={(e) => setCreatedBy(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Assigned To:</label>
            <input
              type="text"
              value={assignedTo}
              onChange={(e) => setAssignedTo(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Created Date:</label>
            <input
              type="date"
              value={createdDate}
              onChange={(e) => setCreatedDate(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Effective Date:</label>
            <input
              type="date"
              value={effectiveDate}
              onChange={(e) => setEffectiveDate(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Expiry Date:</label>
            <input
              type="date"
              value={expiryDate}
              onChange={(e) => setExpiryDate(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Approved By:</label>
            <input
              type="text"
              value={approvedBy}
              onChange={(e) => setApprovedBy(e.target.value)}
            />
          </div>
          
          <div className="form-group">
            <label>Approval Date:</label>
            <input
              type="date"
              value={approvalDate}
              onChange={(e) => setApprovalDate(e.target.value)}
            />
          </div>
          
          <div className="form-group checkbox-group">
            <label>Is Active:</label>
            <input
              type="checkbox"
              checked={isActive}
              onChange={(e) => setIsActive(e.target.checked)}
            />
          </div>
          
          <div className="form-group">
            <label>Image URL:</label>
            <input
              type="text"
              value={imageUrl}
              onChange={(e) => setImageUrl(e.target.value)}
            />
          </div>
        </div>
        
        <div className="form-group full-width">
          <label>Description:</label>
          <textarea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            rows={4}
          />
        </div>
        
        <div className="form-group full-width">
          <label>Notes:</label>
          <textarea
            value={notes}
            onChange={(e) => setNotes(e.target.value)}
            rows={3}
          />
        </div>
        
        <div className="form-group full-width">
          <label>Metadata (JSON):</label>
          <textarea
            value={metadata}
            onChange={(e) => setMetadata(e.target.value)}
            rows={3}
          />
        </div>
      </div>
      
      <div className="actions">
        <button 
          onClick={handleUpload} 
          disabled={isProcessing || !pdfFile}
          className="upload-button"
        >
          {isProcessing ? 'Processing...' : 'Upload Policy'}
        </button>
        <button 
          onClick={resetForm} 
          className="reset-button"
          disabled={isProcessing}
        >
          Reset Form
        </button>
      </div>
    </div>
  );
};

export default UploadPolicy;